{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"aiopmtiles","text":"<p> Async Version of Python PMTiles Reader. </p> <p> </p> <p>Documentation: developmentseed.org/aiopmtiles/</p> <p>Source Code: developmentseed/aiopmtiles</p> <p><code>aiopmtiles</code> is a python <code>Async I/O</code> version of the great PMTiles python reader.</p> <p>The PMTiles format is a Cloud-optimized + compressed single-file tile archives for vector and raster maps.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ python -m pip install pip -U\n\n# From Pypi\n$ python -m pip install aiopmtiles\n\n# Or from source\n$ python -m pip install git+http://github.com/developmentseed/aiopmtiles\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>from aiopmtiles import Reader\n\nasync with Reader(\"https://r2-public.protomaps.com/protomaps-sample-datasets/cb_2018_us_zcta510_500k.pmtiles\") as src:\n    # PMTiles Metadata\n    meta = src.metadata\n\n    # Spatial Metadata\n    bounds = src.bounds\n    minzoom, maxzoom = src.minzoom, src.maxzoom\n\n    # Is the data a Vector Tile Archive\n    assert src.is_vector\n\n    # PMTiles tiles type\n    tile_type = src._header[\"tile_type\"]\n\n    # Tile Compression\n    comp = src.tile_compression\n\n    # Get Tile\n    data = await src.get_tile(0, 0, 0)\n</code></pre>"},{"location":"#contribution-development","title":"Contribution &amp; Development","text":"<p>See CONTRIBUTING.md</p>"},{"location":"#authors","title":"Authors","text":"<p>See contributors</p>"},{"location":"#changes","title":"Changes","text":"<p>See CHANGES.md.</p>"},{"location":"#license","title":"License","text":"<p>See LICENSE</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Issues and pull requests are more than welcome.</p> <p>dev install</p> <pre><code>$ git clone https://github.com/developmentseed/aiopmtiles.git\n$ cd aiopmtiles\n$ python -m pip install -e .[\"test\",\"dev\",\"aws\",\"gcp\"]\n</code></pre> <p>You can then run the tests with the following command:</p> <pre><code>python -m pytest --cov aiopmtiles --cov-report term-missing\n</code></pre> <p>pre-commit</p> <p>This repo is set to use <code>pre-commit</code> to run isort, flake8, pydocstring, black (\"uncompromising Python code formatter\") and mypy when committing new code.</p> <pre><code>$ pre-commit install\n</code></pre>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#010-tmb","title":"0.1.0 (TMB)","text":"<p>Initial release.</p>"},{"location":"usage/","title":"Usage","text":"<p>Create a simple FastAPI application to serve tiles from PMTiles</p> <pre><code>from typing import Dict\n\nfrom fastapi import FastAPI, Path, Query\nfrom pmtiles.tile import Compression\nfrom starlette.middleware.cors import CORSMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nfrom aiopmtiles import Reader\n\n\napp = FastAPI()\n\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"GET\"],\n    allow_headers=[\"*\"],\n)\n\n@app.get(\"/metadata\")\nasync def metadata(url: str = Query(..., description=\"PMTiles archive URL.\")):\n    \"\"\"get Metadata.\"\"\"\n    async with Reader(url) as src:\n        return await src.metadata()\n\n@app.get(\"/tiles/{z}/{x}/{y}\", response_class=Response)\nasync def tiles(\n    z: int = Path(ge=0, le=30, description=\"TMS tiles's zoom level\"),\n    x: int = Path(description=\"TMS tiles's column\"),\n    y: int = Path(description=\"TMS tiles's row\"),\n    url: str = Query(..., description=\"PMTiles archive URL.\"),\n):\n    \"\"\"get Tile.\"\"\"\n    headers: Dict[str, str] = {}\n\n    async with Reader(url) as src:\n        data = await src.get_tile(z, x, y)\n        if src.header[\"internal_compression\"] == Compression.GZIP:\n            headers[\"Content-Encoding\"] = \"gzip\"\n\n    return Response(data, media_type=\"application/x-protobuf\", headers=headers)\n\n@app.get(\"/tilejson.json\")\nasync def tilejson(\n    request: Request,\n    url: str = Query(..., description=\"PMTiles archive URL.\"),\n):\n    \"\"\"get TileJSON.\"\"\"\n    async with Reader(url) as src:\n        tilejson = {\n            \"tilejson\": \"3.0.0\",\n            \"name\": \"pmtiles\",\n            \"version\": \"1.0.0\",\n            \"scheme\": \"xyz\",\n            \"tiles\": [\n                str(request.url_for(\"tiles\", z=\"{z}\", x=\"{x}\", y=\"{y}\")) + f\"?url={url}\"\n            ],\n            \"minzoom\": src.minzoom,\n            \"maxzoom\": src.maxzoom,\n            \"bounds\": src.bounds,\n            \"center\": src.center,\n        }\n\n        # If Vector Tiles then we can try to add more metadata\n        if src.is_vector:\n            if vector_layers := meta.get(\"vector_layers\"):\n                tilejson[\"vector_layers\"] = vector_layers\n\n    return tilejson\n\n\n@app.get(\"/style.json\")\nasync def stylejson(\n    request: Request,\n    url: str = Query(..., description=\"PMTiles archive URL.\"),\n):\n    \"\"\"get StyleJSON.\"\"\"\n    tiles_url = str(request.url_for(\"tiles\", z=\"{z}\", x=\"{x}\", y=\"{y}\")) + f\"?url={url}\"\n\n    async with Reader(url) as src:\n        if src.is_vector:\n            style_json = {\n                \"version\": 8,\n                \"sources\": {\n                    \"pmtiles\": {\n                        \"type\": \"vector\",\n                        \"scheme\": \"xyz\",\n                        \"tiles\": [tiles_url],\n                        \"minzoom\": src.minzoom,\n                        \"maxzoom\": src.maxzoom,\n                        \"bounds\": src.bounds,\n                    },\n                },\n                \"layers\": [],\n                \"center\": [src.center[0], src.center[1]],\n                \"zoom\": src.center[2],\n            }\n\n            meta = await src.metadata()\n            if vector_layers := meta.get(\"vector_layers\"):\n                for layer in vector_layers:\n                    layer_id = layer[\"id\"]\n                    if layer_id == \"mask\":\n                        style_json[\"layers\"].append(\n                            {\n                                \"id\": f\"{layer_id}_fill\",\n                                \"type\": \"fill\",\n                                \"source\": \"pmtiles\",\n                                \"source-layer\": layer_id,\n                                \"filter\": [\"==\", [\"geometry-type\"], \"Polygon\"],\n                                \"paint\": {\n                                    'fill-color': 'black',\n                                    'fill-opacity': 0.8\n                                },\n                            }\n                        )\n\n                    else:\n                        style_json[\"layers\"].append(\n                            {\n                                \"id\": f\"{layer_id}_fill\",\n                                \"type\": \"fill\",\n                                \"source\": \"pmtiles\",\n                                \"source-layer\": layer_id,\n                                \"filter\": [\"==\", [\"geometry-type\"], \"Polygon\"],\n                                \"paint\": {\n                                    'fill-color': 'rgba(200, 100, 240, 0.4)',\n                                    'fill-outline-color': '#000'\n                                },\n                            }\n                        )\n\n                    style_json[\"layers\"].append(\n                        {\n                            \"id\": f\"{layer_id}_stroke\",\n                            \"source\": 'pmtiles',\n                            \"source-layer\": layer_id,\n                            \"type\": 'line',\n                            \"filter\": [\"==\", [\"geometry-type\"], \"LineString\"],\n                            \"paint\": {\n                                'line-color': '#000',\n                                'line-width': 1,\n                                'line-opacity': 0.75\n                            }\n                        }\n                    )\n                    style_json[\"layers\"].append(\n                        {\n                            \"id\": f\"{layer_id}_point\",\n                            \"source\": 'pmtiles',\n                            \"source-layer\": layer_id,\n                            \"type\": 'circle',\n                            \"filter\": [\"==\", [\"geometry-type\"], \"Point\"],\n                            \"paint\": {\n                                'circle-color': '#000',\n                                'circle-radius': 2.5,\n                                'circle-opacity': 0.75\n                            }\n                        }\n                    )\n\n        else:\n            style_json = {\n                \"sources\": {\n                    \"pmtiles\": {\n                        \"type\": \"raster\",\n                        \"scheme\": \"xyz\",\n                        \"tiles\": [tiles_url],\n                        \"minzoom\": src.minzoom,\n                        \"maxzoom\": src.maxzoom,\n                        \"bounds\": src.bounds,\n                    },\n                },\n                \"layers\": [\n                    {\n                        \"id\": \"raster\",\n                        \"type\": \"raster\",\n                        \"source\": \"pmtiles\",\n                    },\n                ],\n                \"center\": [src.center[0], src.center[1]],\n                \"zoom\": src.center[2],\n            }\n\n    return style_json\n</code></pre>"}]}